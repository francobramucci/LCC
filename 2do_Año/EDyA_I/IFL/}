#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/*
 * Encadenamiento: requiere memoria adicional.
 * Listas mezcladas: eliminaciÃ³n costosa. No afecta en este caso.
 * Linear probing: clustering.
 * Doble hash: mayor costo computacional al
 *
 * */

typedef struct _Entrada {
        char *valor;
        int sig;
} Entrada;

typedef struct {
        Entrada **tabla;
        int capacidad;
        int regionDirecciones;
        int ocupados;
        int indiceRegionColisiones;
} TablaHash;

unsigned hash(char *key, int largoTabla) {
    unsigned hashval;

    for (hashval = 0; *key != '\0'; key++) {
        hashval = *key + 31 * hashval;
    }

    return hashval % largoTabla;
}

TablaHash *crear_tabla_hash(int capacidad) {
    TablaHash *tablaHash = malloc(sizeof(TablaHash));
    tablaHash->capacidad = capacidad;
    tablaHash->regionDirecciones = ceil(0.86 * (float)capacidad);
    tablaHash->tabla = calloc(capacidad, sizeof(Entrada *));
    tablaHash->indiceRegionColisiones = capacidad - 1;

    return tablaHash;
}

char *buscar(char *key, TablaHash *hashTable) {
    Entrada **tabla = hashTable->tabla;
    int index = hash(key, hashTable->regionDirecciones);
    if (tabla[index] == NULL)
        return NULL;
    while (strcmp(tabla[index]->valor, key) && index != -1) {
        index = tabla[index]->sig;
    }
    return index == -1 ? NULL : tabla[index]->valor;
}

Entrada *crear_entrada(char *valor) {
    Entrada *entrada = malloc(sizeof(Entrada));
    entrada->valor = valor;
    entrada->sig = -1;

    return entrada;
}

void insertar(char *key, TablaHash *hashTable) {
    Entrada **tabla = hashTable->tabla;
    int index = hash(key, hashTable->regionDirecciones);
    int indiceAnterior;

    if (tabla[index] == NULL) {
        tabla[index] = crear_entrada(key);
        return;
    }

    while (index != -1 && strcmp(tabla[index]->valor, key)) {
        indiceAnterior = index;
        index = tabla[index]->sig;
        fprintf(stderr, "indiceAnterior: %d, index: %d", indiceAnterior, index);
    }
    fprintf(stderr, "indiceAnterior: %d, index: %d", indiceAnterior, index);
    if (index == -1) {
        int indiceRegionColisiones = hashTable->indiceRegionColisiones;
        while (tabla[indiceRegionColisiones] != NULL)
            indiceRegionColisiones--;
        hashTable->indiceRegionColisiones = indiceRegionColisiones;
        if (indiceRegionColisiones == -1) // Overflow
            return;
        tabla[indiceAnterior]->sig = indiceRegionColisiones;
        tabla[indiceRegionColisiones] = crear_entrada(key);
    }
}

void imprimir_tabla_hash(TablaHash *tabla) {
    printf("%-10s | %-15s | %s\n", "Posicion", "Valor", "Siguiente");
    printf("-------------------------------------------\n");
    for (int i = 0; i < tabla->capacidad; i++) {
        char *valor = tabla->tabla[i] == NULL ? "NULL" : tabla->tabla[i]->valor;
        int sig = tabla->tabla[i] == NULL ? -1 : tabla->tabla[i]->sig;

        // Print each row with aligned columns
        printf("%-10d | %-15s | %d\n", i, valor, sig);
    }
}

int main() {
    TablaHash *hTable = crear_tabla_hash(11);
    char *p = "pepe";
    char *p1 = "pepe1";
    char *p2 = "pepe2";
    // char *p3 = "pepe3";
    // char *p4 = "pepe4";
    // char *p5 = "pepe5";
    // char *p6 = "pepe6";
    // char *p7 = "pepe7";
    // char *p8 = "pepe8";
    // char *p9 = "pepe9";
    // char *p10 = "pepe10";
    // char *p11 = "pepe11";
    insertar(p, hTable);
    insertar(p1, hTable);
    insertar(p2, hTable);
    // insertar(p3, hTable);
    // insertar(p4, hTable);
    // insertar(p5, hTable);
    // insertar(p6, hTable);
    // insertar(p7, hTable);
    // insertar(p8, hTable);
    // insertar(p9, hTable);
    // insertar(p10, hTable);
    // insertar(p11, hTable);
    imprimir_tabla_hash(hTable);
    char *a = buscar("pepe2", hTable);
    printf("\b%s", a);
    return 0;
}
