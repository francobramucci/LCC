#include "thash.h"
#include <assert.h>
#include <math.h>
#include <string.h>

/*
 * Calcula un valor hash para una cadena de caracteres.
 * La función recorre cada carácter de la cadena y combina su valor con un factor multiplicativo.
 * Devuelve el hash reducido al tamaño de la tabla (largoTabla) usando módulo.
 */
// static unsigned thash_hash(char *key, int largoTabla);

/*
 * Redimensiona la tabla hash duplicando su capacidad.
 * Recalcula la región de colisiones y la tabla interna, y vuelve a insertar todas las entradas
 * de la tabla anterior. Libera la memoria de la tabla antigua después de la reinserción.
 */
static void thash_rehash(THash *tablaHash);

/*
 * Crea una nueva entrada para la tabla hash.
 * Asigna memoria para la entrada, inicializa su clave, valor y el índice de la siguiente entrada en la lista mezclada
 * (sig) a -1.
 */
static Entrada *entrada_crear(void *key, void *valor);

/*
 * Determina si un número entero n es primo.
 * Retorna 1 si es primo, 0 en caso contrario.
 * Descarta múltiplos de 2 y 3 y luego verifica el resto de la division con números de la forma 6k +- 1 ya que todo
 * numero primero > 3 puede expresarse de esa forma.
 */
static int es_primo(int n);

/*
 * Encuentra el número primo más cercano a n.
 * Busca tanto hacia abajo como hacia arriba desde n hasta encontrar un primo y lo retorna.
 */
static int primo_mas_cercano(int n);

static void *retornar_puntero(void *dato);

/*
 * Encadenamiento: requiere memoria adicional.
 * Listas mezcladas: eliminación costosa. No afecta en este caso.
 * Linear probing: clustering.
 * Doble hash: mayor costo computacional al
 * */

THash *thash_crear(int capacidad, FuncionHash hash, FuncionCopiadora copiarKey, FuncionCopiadora copiarValor,
                   FuncionDestructora destruirKey, FuncionDestructora destruirValor, FuncionComparadora compararKeys) {
    THash *tablaHash = malloc(sizeof(THash));
    assert(tablaHash);
    tablaHash->capacidad = capacidad;
    tablaHash->tamRegionDirecciones = primo_mas_cercano(ceil(0.86 * (float)capacidad));
    tablaHash->tabla = calloc(capacidad, sizeof(Entrada *));
    tablaHash->indiceRegionColisiones = capacidad - 1;
    tablaHash->hash = hash;
    tablaHash->copiarKey = copiarKey;
    tablaHash->copiarValor = copiarValor;
    tablaHash->destruirKey = destruirKey;
    tablaHash->destruirValor = destruirValor;
    tablaHash->compararKeys = compararKeys;

    return tablaHash;
}

void *thash_buscar(void *key, THash *tablaHash) {
    Entrada **tabla = tablaHash->tabla;
    int index = tablaHash->hash(key) % tablaHash->tamRegionDirecciones;
    if (tabla[index] == NULL)
        return NULL;
    while (index != -1 && tablaHash->compararKeys(tabla[index]->key, key)) {
        index = tabla[index]->sig;
    }
    return index == -1 ? NULL : tabla[index]->valor;
}

void thash_insertar(void *key, void *value, THash *tablaHash) {
    Entrada **tabla = tablaHash->tabla;
    int index = tablaHash->hash(key) % tablaHash->tamRegionDirecciones;
    int indiceAnterior;

    if (tabla[index] == NULL) {
        tabla[index] = entrada_crear(tablaHash->copiarKey(key), tablaHash->copiarValor(value));
        return;
    }

    while (index != -1 && tablaHash->compararKeys(tabla[index]->key, key)) {
        indiceAnterior = index;
        index = tabla[index]->sig;
    }

    if (index == -1) {
        int indiceRegionColisiones = tablaHash->indiceRegionColisiones;
        while (indiceRegionColisiones >= 0 && tabla[indiceRegionColisiones] != NULL)
            indiceRegionColisiones--;
        tablaHash->indiceRegionColisiones = indiceRegionColisiones;
        if (indiceRegionColisiones == -1) { // Tabla llena, rehash
            thash_rehash(tablaHash);
            thash_insertar(key, value, tablaHash);
            return;
        }
        tabla[indiceAnterior]->sig = indiceRegionColisiones;
        tabla[indiceRegionColisiones] = entrada_crear(tablaHash->copiarKey(key), tablaHash->copiarValor(value));
    }
}

void thash_destruir(THash *tablaHash) {
    Entrada **tabla = tablaHash->tabla;
    for (int i = 0; i < tablaHash->capacidad; i++) {
        if (tabla[i] != NULL) {
            tablaHash->destruirKey(tabla[i]->key);
            tablaHash->destruirValor(tabla[i]->valor);
            free(tabla[i]);
        }
    }
    free(tabla);
    free(tablaHash);
}

// static unsigned thash_hash(char *key, int largoTabla) {
//     unsigned hashval;
//
//     for (hashval = 0; *key != '\0'; key++) {
//         hashval = *key + 67 * hashval;
//     }
//
//     return hashval % largoTabla;
// }

static void thash_rehash(THash *tablaHash) {
    THash tablaVieja = *tablaHash;
    tablaHash->capacidad *= 2;
    tablaHash->indiceRegionColisiones = tablaHash->capacidad - 1;
    tablaHash->tabla = calloc(tablaHash->capacidad, sizeof(Entrada *));
    assert(tablaHash->tabla);
    tablaHash->tamRegionDirecciones = primo_mas_cercano(ceil(0.86 * (float)tablaHash->capacidad));

    FuncionCopiadora copiarKey = tablaHash->copiarKey;
    FuncionCopiadora copiarValor = tablaHash->copiarValor;
    // Como no queremos hacer otras copias físicas del dato y la llave
    // modificamos temporalmente las funciones de copia a una que
    // retorna los punteros y reutilizamos thash_insertar.
    tablaHash->copiarKey = (FuncionCopiadora)retornar_puntero;
    tablaHash->copiarValor = (FuncionCopiadora)retornar_puntero;

    for (int i = 0; i < tablaVieja.capacidad; i++) {
        if (tablaVieja.tabla[i] != NULL) {
            thash_insertar(tablaVieja.tabla[i]->key, tablaVieja.tabla[i]->valor, tablaHash);
            free(tablaVieja.tabla[i]);
        }
    }

    tablaHash->copiarKey = copiarKey;
    tablaHash->copiarValor = copiarValor;

    free(tablaVieja.tabla);
}

static Entrada *entrada_crear(void *key, void *valor) {
    Entrada *entrada = malloc(sizeof(Entrada));
    assert(entrada);
    entrada->key = key;
    entrada->valor = valor;
    entrada->sig = -1;

    return entrada;
}

static int es_primo(int n) {
    if (n <= 1)
        return 0;
    if (n <= 3)
        return 1;
    if (n % 2 == 0 || n % 3 == 0)
        return 0;

    int esPrimo = 1;

    for (int i = 5; i * i <= n && esPrimo; i = i + 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            esPrimo = 0;
    }

    return esPrimo;
}

static int primo_mas_cercano(int n) {
    int p = 0;

    for (int i = 0; p == 0; i++) {
        if (es_primo(n - i))
            p = n - i;
        else if (es_primo(n + i))
            p = n + i;
    }

    return p;
}

static void *retornar_puntero(void *dato) {
    return dato;
}
